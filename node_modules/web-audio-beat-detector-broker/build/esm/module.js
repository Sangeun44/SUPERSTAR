var _this = this;
import * as tslib_1 from "tslib";
import { addUniqueNumber } from 'fast-unique-numbers';
import { isSupported } from 'standardized-audio-context';
import { render } from './helpers/render';
export { isSupported };
export var load = function (url) {
    var worker = new Worker(url);
    var ongoingRecordingRequests = new Set();
    var analyze = function (audioBuffer, offset, duration) {
        if (offset === void 0) { offset = 0; }
        if (duration === void 0) { duration = audioBuffer.duration - offset; }
        return new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, channelData, sampleRate, id, onMessage;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, render(audioBuffer, offset, duration)];
                    case 1:
                        _a = _b.sent(), channelData = _a.channelData, sampleRate = _a.sampleRate;
                        id = addUniqueNumber(ongoingRecordingRequests);
                        onMessage = function (_a) {
                            var data = _a.data;
                            if (data.id === id) {
                                ongoingRecordingRequests.delete(id);
                                worker.removeEventListener('message', onMessage);
                                if (data.error === null) {
                                    resolve(data.result.tempo);
                                }
                                else {
                                    reject(new Error(data.error.message));
                                }
                            }
                        };
                        worker.addEventListener('message', onMessage);
                        worker.postMessage({ id: id, method: 'analyze', params: { channelData: channelData, sampleRate: sampleRate } }, [channelData.buffer]);
                        return [2 /*return*/];
                }
            });
        }); });
    };
    var guess = function (audioBuffer, offset, duration) {
        if (offset === void 0) { offset = 0; }
        if (duration === void 0) { duration = audioBuffer.duration - offset; }
        return new Promise(function (resolve, reject) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var _a, channelData, sampleRate, id, onMessage;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, render(audioBuffer, offset, duration)];
                    case 1:
                        _a = _b.sent(), channelData = _a.channelData, sampleRate = _a.sampleRate;
                        id = addUniqueNumber(ongoingRecordingRequests);
                        onMessage = function (_a) {
                            var data = _a.data;
                            if (data.id === id) {
                                ongoingRecordingRequests.delete(id);
                                worker.removeEventListener('message', onMessage);
                                if (data.error === null) {
                                    resolve(data.result);
                                }
                                else {
                                    reject(new Error(data.error.message));
                                }
                            }
                        };
                        worker.addEventListener('message', onMessage);
                        worker.postMessage({ id: id, method: 'guess', params: { channelData: channelData, sampleRate: sampleRate } }, [channelData.buffer]);
                        return [2 /*return*/];
                }
            });
        }); });
    };
    return {
        analyze: analyze,
        guess: guess
    };
};
//# sourceMappingURL=/build/es2015/module.js.map